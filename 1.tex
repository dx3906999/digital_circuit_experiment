\documentclass[a4paper]{article}
\usepackage[margin=1in]{geometry}
\usepackage[dvipsnames, svgnames, x11names]{xcolor}
\usepackage{ctex, cite, amsfonts, amsmath, graphicx, lipsum, amssymb, url, listings, bm, float, siunitx, framed, color, tikz, booktabs, fontspec, unicode-math, mdframed, tcolorbox, fancyhdr, titling}
\usepackage{minted}
\tcbuselibrary{minted}
\tcbuselibrary{skins, listingsutf8, breakable}
\usepackage[sort&compress]{gbt7714}
\usepackage[colorlinks=true, citecolor=black]{hyperref}
\usepackage{cleveref}
\setmainfont{Times New Roman}
\setsansfont{Arial}
\setmonofont{SpaceMono Nerd Font}
\setCJKmainfont[AutoFakeBold=true]{SimSun}
\setCJKsansfont[AutoFakeBold=3]{楷体}
\setCJKmonofont[AutoFakeBold=3]{SimHei}
\DeclareFontFamily{U}{bbold}{\skewchar\font127 }
\DeclareFontShape{U}{bbold}{m}{n}{
   <-6> bbold5
   <6-8> bbold7
   <8-> bbold10
}{}
\hypersetup{pdftitle={}, pdfauthor={Crazy\_13754}}
% \begin{tcblisting}{listing engine=minted,boxrule=0.1mm,colback=blue!5!white,breakable,colframe=blue!75!black,listing only,left=5mm,minted options={fontsize=\small,breaklines, autogobble,linenos,numbersep=3mm,escapeinside=||},minted language=text}
% \end{tcblisting}
\definecolor{LightGray}{gray}{0.9}
\definecolor{darkgray}{gray}{0.3}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{24 秋季学期}
\fancyhead[C]{课程作业}
\fancyhead[R]{网络空间安全导论}

\fancyfoot[C]{\thepage}

\newmdenv[leftline=true, linecolor=gray, linewidth=2pt, topline=false, bottomline=false, rightline=false, leftmargin=10pt,  font=\sffamily\color{darkgray}]{quoted}

\newtcolorbox{citebox}{boxrule=0pt, left=10mm, right=10mm, top=5mm, bottom=5mm, fonttitle=\bfseries, sharp corners, before skip=10pt, after skip=10pt}
\newcommand{\upcite}[1]{	extsuperscript{\cite{#1}}}
\citestyle{numbers}

\begin{document}

\title{数字电路实验报告——源码文档}
\author{张荣宸、罗浙元、毕冠华}
\date{}

\maketitle
% \tableofcontents
% \newpage

% \section{总述}
% 主要代码由以下部分组成：
% \paragraph{ArbPriority} 优先级仲裁器，用于多个请求信号的优先级判断。
% \paragraph{binary\_to\_decimal} 二进制转十进制模块，用于将二进制数转换为十进制数。
% \paragraph{cnt\_1s} 1s计数器，用于计算1s的时间。
% \paragraph{key\_filter} 按键消抖模块，用于消抖按键信号。
% \paragraph{eshelby\_screen} 素数筛模块，用于筛选素数。
% \paragraph{key\_mode} 按键模式切换模块，用于按键模式切换。

% \section{代码}
\subsection*{ArbPriority}

该 ArbPriority 是老师提供的。

% \paragraph{功能描述} 优先级仲裁器，用于多个请求信号的优先级判断。

% \paragraph{输入输出端口：}
% \begin{itemize}
%     \item \texttt{clk} 和 \texttt{rstn}：时钟和复位信号。
%     \item \texttt{req\_i}：\texttt{N} 位的请求输入信号，每一位代表一个请求。
%     \item \texttt{prio}：\texttt{N} 位的优先级输入信号，每一位代表对应请求的优先级。
%     \item \texttt{ack\_i}：\texttt{N} 位的响应输出信号，每一位代表对应请求的响应。
%     \item \texttt{req\_o}：总请求输出信号，当任意请求有效时，该信号为高。
%     \item \texttt{ack\_o}：总响应输入信号，当仲裁器选择的请求被响应时，该信号为高。
% \end{itemize}

% \paragraph{内部信号} \texttt{token} 用于存储仲裁过程中生成的中间信号，长度为 \texttt{2*N}。

% \paragraph{逻辑功能：}
% \begin{itemize}
%     \item \texttt{req\_o}：当任意请求有效时，\texttt{req\_o} 为高。
%     \item 仲裁逻辑通过 \texttt{generate} 语句生成 \texttt{N} 个仲裁单元，每个单元根据优先级和请求信号生成响应信号和中间信号 \texttt{token}。
%     \item 对于第一个请求（\texttt{i==0}），响应信号 \texttt{ack\_i[0]} 由优先级信号 \texttt{prio[0]}、中间信号 \texttt{token[N-1]}、请求信号 \texttt{req\_i[0]} 和总响应信号 \texttt{ack\_o} 共同决定。中间信号 \texttt{token[0]} 和 \texttt{token[N]} 分别由优先级信号 \texttt{prio[0]} 和请求信号 \texttt{req\_i[0]} 决定。
%     \item 对于其他请求（\texttt{i>0}），响应信号 \texttt{ack\_i[i]} 由前一个请求的中间信号 \texttt{token[i-1]}、当前请求的优先级信号 \texttt{prio[i]}、当前请求的中间信号 \texttt{token[N+i-1]}、请求信号 \texttt{req\_i[i]} 和总响应信号 \texttt{ack\_o} 共同决定。中间信号 \texttt{token[i]} 和 \texttt{token[N+i]} 分别由前一个请求的中间信号 \texttt{token[i-1]}、当前请求的优先级信号 \texttt{prio[i]} 和请求信号 \texttt{req\_i[i]} 决定。
% \end{itemize}

\begin{tcblisting}{listing engine=minted,boxrule=0.1mm,colback=blue!5!white,breakable,colframe=blue!75!black,listing only,left=5mm,minted options={fontsize=\small,breaklines, autogobble,linenos,numbersep=3mm},minted language=verilog}
module ArbPriority
    #(parameter N=8)
     (input clk, rstn,
     input [N-1:0] req_i,
     input [N-1:0] prio,
     output [N-1:0] ack_i,
     output req_o,
     input ack_o);

    genvar i;
    wire token[2*N-1:0];


    assign req_o = |req_i;
    generate for(i=0; i<N; i=i+1) begin
      if(i==0) begin
        assign ack_i[0] = (prio[0] | token[N-1]) & req_i[0] & ack_o;
        assign token[0] = prio[0] & ~req_i[0];
        assign token[N] = token[N-1] & ~req_i[0];
      end else begin
        assign ack_i[i] = (token[i-1] | prio[i] | token[N+i-1]) & req_i[i] & ack_o;
        assign token[i] = (token[i-1] | prio[i]) & ~req_i[i];
        assign token[N+i] = token[N+i-1] & ~req_i[i];
      end
    end endgenerate
endmodule
\end{tcblisting}

\subsection*{binary\_to\_decimal}
% \paragraph{功能描述} 二进制转十进制模块，用于将二进制数转换为十进制数。

% \paragraph{输入输出端口：}
% \begin{itemize}
%     \item \texttt{binary}：\texttt{N} 位的二进制输入信号。
%     \item \texttt{output\_data}：24 位的十进制输出信号。
% \end{itemize}

% \paragraph{内部信号} \texttt{register} 用于存储转换过程中的中间结果，长度为 24 位。

% \paragraph{逻辑功能}
% 模块使用双重循环将二进制数转换为十进制数。外层循环遍历二进制输入信号的每一位。内层循环检查并调整寄存器中的每一位，使其符合 BCD（Binary-Coded Decimal）编码规则。

\begin{tcblisting}{listing engine=minted,boxrule=0.1mm,colback=blue!5!white,breakable,colframe=blue!75!black,listing only,left=5mm,minted options={fontsize=\small,breaklines, autogobble,linenos,numbersep=3mm,escapeinside=||},minted language=verilog}
module binary_to_decimal #(parameter N = 20)
(
    input [N-1:0] binary,
    output [23:0] output_data
    );

    reg [23:0] register;

integer i;
integer j;
    always @(binary) begin
        register = 24'd0;

        for (i = 19;i >= 0; i = i-1) begin
            for (j = 0; j <= 5; j = j+1) begin
                if (register[(4*j)+3-:4]>= 4'b0101) register[(4*j)+3-:4] = register[(4*j)+3-:4] + 4'b0011;
            end
            register = {register[22:0], binary[i]};

        end
    end
    assign output_data = register;
endmodule
\end{tcblisting}

\subsection*{cnt\_1s}

% \paragraph{功能描述} 1s计数器，用于计算1s的时间。

% \paragraph{输入输出端口：}
% \begin{itemize}
%     \item \texttt{clk}：系统时钟信号。
%     \item \texttt{rstn}：复位信号。
%     \item \texttt{clk\_o}：1s计数输出信号。
% \end{itemize}

% \paragraph{内部信号} \texttt{cnt\_1s} 用于存储计数器的计数值，长度为 26 位。

% \paragraph{逻辑功能}
% 计数器使用 20ns 的时钟信号计数，每计数到 25,000,000 时钟周期（即 1s）输出一个高电平的时钟信号。

\begin{tcblisting}{listing engine=minted,boxrule=0.1mm,colback=blue!5!white,breakable,colframe=blue!75!black,listing only,left=5mm,minted options={fontsize=\small,breaklines, autogobble,linenos,numbersep=3mm,escapeinside=||},minted language=verilog}
//使用20ns的时钟clk
module cnt_1s #(parameter CNT_1S_HALF_MAX = 25_000_000)
(
	input wire clk,
	input wire rstn,
	output clk_o
);

reg	[25:0] cnt_1s;
reg clk_o_reg;
//cnt_1s:1s计数�?
assign clk_o=clk_o_reg;
always@(posedge clk or negedge rstn) begin
	if(rstn == 1'b0) begin
		cnt_1s <= 26'b0;
        clk_o_reg <=	1'b0;
		end
	else if(cnt_1s >= CNT_1S_HALF_MAX) begin
		cnt_1s <= 26'b0;
        clk_o_reg <=	~clk_o_reg;
		end
	else
		cnt_1s <= cnt_1s + 1;
	end
endmodule
\end{tcblisting}

% \subsection*{key\_filter}

% \paragraph{功能描述} 按键消抖模块，用于消抖按键信号。

% \paragraph{输入输出端口：}
% \begin{itemize}
%     \item \texttt{clk}：系统时钟信号。
%     \item \texttt{rstn}：复位信号。
%     \item \texttt{key\_in}：按键输入信号。
%     \item \texttt{state}：按键有效标志位。
% \end{itemize}

% \paragraph{逻辑功能}
% 按键消抖模块使用 20ms 的时钟信号计数，每计数到 999,999 时钟周期（即 20ms）输出一个高电平的按键有效标志位。

% \begin{tcblisting}{listing engine=minted,boxrule=0.1mm,colback=blue!5!white,breakable,colframe=blue!75!black,listing only,left=5mm,minted options={fontsize=\small,breaklines, autogobble,linenos,numbersep=3mm,escapeinside=||},minted language=verilog}
%     module key_filter
%     #(
%     parameter CNT_MAX = 20'd999_999 //计数器计数最大值
%     )
%     (
%     input wire clk , //系统时钟50MHz
%     input wire rstn ,
%     input wire key_in , //按键输入信号

%     output reg state //key_flag为1时表示消抖后检测到按键被按下
%     //key_flag为0时表示没有检测到按键被按下
%     );


%     reg [19:0] cnt_20ms ; //计数器
%     reg key_flag;


%     //外部按键输入的值为低电平时，计数器开始计数
%     always@(posedge clk or negedge rstn)
%     if(rstn == 1'b0) cnt_20ms <= 20'b0;
%     else if(key_in == 1'b1) cnt_20ms <= 20'b0;
%     else if(cnt_20ms == CNT_MAX && key_in == 1'b0) cnt_20ms <= cnt_20ms;
%     else cnt_20ms <= cnt_20ms + 1'b1;

%     //key_flag:当计数满20ms后产生按键有效标志位
%     //且key_flag在cnt_20ms=999_999时拉高,维持一个时钟的高电平
%     always@(posedge clk or negedge rstn)
%     if(rstn == 1'b0)
%     key_flag <= 1'b0;
%     else if(cnt_20ms == CNT_MAX - 1'b1)
%     key_flag <= 1'b1;
%     else
%     key_flag <= 1'b0;

%     reg key_flag_sync1, key_flag_sync2;

%     always @(posedge clk or negedge rstn) begin
%         if (~rstn) begin
%             key_flag_sync1 <= 0;
%             key_flag_sync2 <= 0;
%             state <= 0;
%         end else begin
%             key_flag_sync1 <= key_flag;  // 第一级同步
%             key_flag_sync2 <= key_flag_sync1;  // 第二级同步

%             if (key_flag_sync2 == 1 && key_flag_sync1 == 0) begin
%                 state <= ~state;  // 在上升沿时翻转state
%             end
%         end
%     end


%     endmodule
% \end{tcblisting}

\subsection*{eshelby\_screen}

% \paragraph{功能描述} 素数筛模块，用于筛选素数。

% \paragraph{逻辑功能}
% \begin{itemize}
%     \item 模块使用 SRAM 存储筛选结果，每个地址对应一个数，存储该数是否为素数。
%     \item 模块使用两个计数器 \texttt{index\_kill} 和 \texttt{index\_prime} 分别记录当前筛选的数和当前素数。
%     \item 模块使用状态机实现筛选逻辑。状态机包括以下状态：
%      \begin{itemize}
%         \item \texttt{KILLER\_STATE}：筛选合数状态，将当前素数的倍数标记为合数。
%         \item \texttt{CHECK\_PRIME\_STATE}：检查素数状态，检查下一个数是否为素数。
%         \item \texttt{READ\_TO\_CHECK\_STATE}：等待 SRAM 读取状态，等待 SRAM 读取下一个数。
%         \item \texttt{INITIAL\_STATE}：初始化状态，初始化计数器和 SRAM。
%         \item \texttt{DONE\_STATE}：筛选完成状态，筛选完成。
%      \end{itemize}
%     \item 模块使用两个状态机 \texttt{state} 和 \texttt{output\_state} 分别控制筛选和输出逻辑。其中，\texttt{output\_state} 用于输出素数。
% \end{itemize}

\begin{tcblisting}{listing engine=minted,boxrule=0.1mm,colback=blue!5!white,breakable,colframe=blue!75!black,listing only,left=5mm,minted options={fontsize=\small,breaklines, autogobble,linenos,numbersep=3mm,escapeinside=||},minted language=verilog}
    module eshelby_screen (
        input clk,
        input rstn,
        input timer,
        input mode,     // 0: search for next prime, 1: suspend
        output [19:0] prime_num
    );
        // sram
        reg [19:0] w_addr;
        reg  w_data;
        wire [19:0] r_addr;
        wire  r_data;

        blk_mem_gen_0 blk_ram(
            .clka(clk),
            .clkb(clk),
            .wea(1'b1),
            .addra(w_addr),
            .dina(w_data),
            .addrb(r_addr),
            .doutb(r_data)
        );

        reg [19:0] index_kill;
        reg [19:0] index_prime;
        reg [19:0] last_prime;
        wire [39:0] index_prime_square;
        localparam IS_PRIME = 1'b0;
        localparam NOT_PRIME = 1'b1;


        // state
        reg [2:0] state;
        localparam KILLER_STATE = 3'b000;
        localparam CHECK_PRIME_STATE = 3'b001;
        localparam READ_TO_CHECK_STATE = 3'b010;
        localparam INITIAL_STATE = 3'b011;
        localparam DONE_STATE = 3'b100;
        localparam WAITING_FOR_RT_STATE = 3'b101;// 所有这些都要减少一个周期

        reg [2:0] output_state;
        localparam SEARCHING_NEXT_STATE=3'b000;
        localparam WAITING_FOR_OUTPUT_STATE=3'b001;
        localparam READ_TO_SEARCH_STATE=3'b010;
        localparam WAITING_FOR_PRIME_STATE=3'b011;
        // localparam WAITING_FOR_O_STATE

        reg [19:0] index_output;
        reg [19:0] prime_num_reg;
        assign prime_num=prime_num_reg;

        // arbiter
        reg [1:0] req;
        wire [1:0] prio;
        wire [1:0] ack;

        assign prio=(index_output<last_prime || state==DONE_STATE)?(2'b10):(2'b01);
        assign index_prime_square=index_prime*index_prime;
        assign r_addr=(ack==0)?(0):(ack[0])?(index_prime):(index_output);

        ArbPriority#(.N(2)) arbiter (
            .clk(clk),
            .rstn(rstn),
            .req_i(req),
            .prio(prio),
            .ack_i(ack),
            .req_o(),
            .ack_o(1'b1)
        );

        // assign r_addr=(ack==0)?(0):()

        always @(posedge clk or negedge rstn) begin
            if (~rstn) begin
                w_addr<=2;
                w_data<=IS_PRIME;
                // r_addr<=0;
                index_kill<=0;
                index_prime<=0;
                last_prime<=0;
                state<=INITIAL_STATE;
                req[0]<=0;
            end else begin
                case (state)
                    INITIAL_STATE: begin
                        index_kill<=4;
                        index_prime<=2;
                        last_prime<=2;
                        w_addr<=2;
                        w_data<=IS_PRIME;
                        state<=KILLER_STATE;
                    end
                    KILLER_STATE: begin
                        if (index_kill<index_prime_square && index_kill<=999999) begin
                            index_kill<=index_prime_square;
                            state<=KILLER_STATE;
                        end else if (index_kill>=index_prime_square && index_kill<=999999) begin
                            w_addr<=index_kill;
                            w_data<=NOT_PRIME;
                            index_kill<=index_kill+index_prime;
                            state<=KILLER_STATE;
                        end else begin
                            state<=READ_TO_CHECK_STATE;
                            index_kill<=index_prime+1;
                            index_prime<=index_prime+1;
                            last_prime<=index_prime;
                            req[0]<=1'b1;
                        end
                    end
                    READ_TO_CHECK_STATE: begin
                        if (ack[0]&&~ack[1]) begin
                            // r_addr<=index_prime;
                            req[0]<=1'b0;
                            state<=WAITING_FOR_RT_STATE;
                        end else begin
                            req[0]<=1'b1;
                            state<=READ_TO_CHECK_STATE;
                        end
                    end
                    CHECK_PRIME_STATE: begin
                        if (r_data==NOT_PRIME && index_prime<=999999) begin
                            index_prime<=index_prime+1;
                            state<=READ_TO_CHECK_STATE;
                        end else if (r_data==IS_PRIME && index_prime<=999999) begin
                            if (index_prime_square>999999) begin
                                state<=DONE_STATE;
                            end else begin
                                index_kill<=index_prime_square;
                                state<=KILLER_STATE;
                            end
                        end else begin
                            state<=DONE_STATE;
                        end
                    end
                    WAITING_FOR_RT_STATE: begin
                        state<=CHECK_PRIME_STATE;
                    end
                    DONE_STATE: begin
                        state<=DONE_STATE;
                    end
                endcase
            end
        end

        always @(posedge clk or negedge rstn) begin
            if (~rstn) begin
                index_output<=2;
                req[1]<=0;
                output_state<=READ_TO_SEARCH_STATE;
            end else begin
                case (output_state)
                    READ_TO_SEARCH_STATE: begin
                        if (ack[1]&&~ack[0]) begin
                            // r_addr<=index_output;
                            req[1]<=1'b0;
                            output_state<=WAITING_FOR_RT_STATE;
                        end else begin
                            req[1]<=1'b1;
                            output_state<=READ_TO_SEARCH_STATE;
                        end
                    end
                    SEARCHING_NEXT_STATE: begin
                        if (r_data==NOT_PRIME && (index_output<last_prime || state==DONE_STATE)) begin
                            index_output<=index_output+1;
                            output_state<=READ_TO_SEARCH_STATE;
                        end else if (r_data==IS_PRIME && (index_output<last_prime || state==DONE_STATE)) begin
                            output_state<=WAITING_FOR_OUTPUT_STATE;
                        end else begin
                            output_state<=WAITING_FOR_PRIME_STATE;
                        end
                    end
                    WAITING_FOR_OUTPUT_STATE: begin
                        if(prime_num==index_output && mode) begin
                            output_state<=READ_TO_SEARCH_STATE;
                            index_output<=index_output+1;
                            req[1]<=1'b1;
                        end else begin
                            output_state<=WAITING_FOR_OUTPUT_STATE;
                        end
                    end
                    WAITING_FOR_PRIME_STATE: begin
                        if (index_output<last_prime || state==DONE_STATE) begin
                            req[1]<=1'b1;
                            output_state<=READ_TO_SEARCH_STATE;
                        end else begin
                            output_state<=WAITING_FOR_PRIME_STATE;
                        end
                    end
                    WAITING_FOR_RT_STATE: begin
                        output_state<=SEARCHING_NEXT_STATE;
                    end

                endcase
            end
        end

        always @(posedge timer or negedge rstn) begin
            if (~rstn) begin
                prime_num_reg<=2;
            end else begin
                if (output_state==WAITING_FOR_OUTPUT_STATE) begin
                    prime_num_reg<=index_output;
                end
            end
        end

    endmodule
\end{tcblisting}

\subsection*{key\_mode}

% \paragraph{功能描述} 按键模式切换模块，用于按键模式切换。

% \paragraph{输入输出端口：}
% \begin{itemize}
%     \item \texttt{clk}：系统时钟信号。
%     \item \texttt{rstn}：复位信号。
%     \item \texttt{key\_in}：按键输入信号。
%     \item \texttt{mode}：模式切换信号。
% \end{itemize}

% \paragraph{逻辑功能}
% \begin{itemize}
%     \item 模块使用两级同步器消抖按键信号。
%     \item 模块使用计数器计数按键按下时间，当按键按下时间达到 \texttt{N} 时钟周期时，输出模式切换信号。
%     \item 模块使用状态机实现模式切换逻辑。状态机包括以下状态：
%      \begin{itemize}
%         \item \texttt{IDLE}：空闲状态，等待按键按下。
%         \item \texttt{WAIT\_RELEASE}：等待释放状态，等待按键释放。
%         \item \texttt{SWITCH}：切换状态，切换模式。
%      \end{itemize}
% \end{itemize}

\begin{tcblisting}{listing engine=minted,boxrule=0.1mm,colback=blue!5!white,breakable,colframe=blue!75!black,listing only,left=5mm,minted options={fontsize=\small,breaklines, autogobble,linenos,numbersep=3mm,escapeinside=||},minted language=verilog}
    module key_mode #(parameter N = 1_000_000)(
        input clk,//系统时钟50MHz
        input rstn,//复位信号
        input key_in,//按键输入信号
        output mode//模式切换信号
    );
        reg mode_reg;//位宽取决于N的值
        reg key_flag_sync1, key_flag_sync2;
        reg state;
        reg [20:0] cnt;
        always @(posedge clk or negedge rstn) begin
            if (~rstn) cnt <= 24'd0;
            else if (key_in == 1) cnt <= 0;
            else if (key_in==0) cnt<=(cnt<N)?cnt+1:cnt;
            end
        always@(posedge clk or negedge rstn) begin
            if (~rstn) mode_reg <=1'b0;
            else if (cnt == N-1) mode_reg <= 1'b1;//且cnt在999_999时拉高,维持一个时钟的高电平
            else mode_reg <= 1'b0;
        end

        always @(posedge clk or negedge rstn) begin
            if (~rstn) begin
                key_flag_sync1 <= 0;
                key_flag_sync2 <= 0;
                state <= 0;
            end else begin
                key_flag_sync1 <= mode_reg;  // 第一级同步
                key_flag_sync2 <= key_flag_sync1;  // 第二级同步

                if (key_flag_sync2 == 1 && key_flag_sync1 == 0) begin
                    state <= ~state;  // 在上升沿时翻转state
                end
            end
        end
        assign mode = state;
    endmodule
\end{tcblisting}

\subsection{top}

\begin{tcblisting}{listing engine=minted,boxrule=0.1mm,colback=blue!5!white,breakable,colframe=blue!75!black,listing only,left=5mm,minted options={fontsize=\small,breaklines, autogobble,linenos,numbersep=3mm,escapeinside=||},minted language=verilog}
    module top(
    input clk,
    input rstn,
    output [3:0] led,
    input [3:0] key,
    output [5:0] seg_sel,
    output [7:0] seg_dig
);

    reg [3:0] led;

    always @(posedge clk or negedge rstn)
    if(!rstn)
        led <= 0;
    else
        led <= led ^ (~key);

    reg [23:0] cnt;
    wire [6*8-1:0] seg;

    always @(posedge clk or negedge rstn)
    if(!rstn)
        cnt <= 0;
    else begin
        if(~key[0]) cnt = cnt + 1;
        if(~key[1]) cnt = cnt + 2;
        if(~key[2]) cnt = cnt + 4;
        if(~key[3]) cnt = cnt + 8;
    end

    genvar i;
    generate for(i=0; i<6; i=i+1) begin
            led7seg_decode d(cnt[i*4 +: 4], 1'b1, seg[i*8 +: 8]);
        end
    endgenerate

    seg_driver #(6) driver(clk, rstn, 6'b111111, seg, seg_sel, seg_dig);

endmodule

module seg_driver #(parameter NPorts=8) (
    input clk, rstn,
    input [NPorts-1:0]   valid_i, // input port valid
    input [NPorts*8-1:0] seg_i, // segment inputs
    output reg [NPorts-1:0]  valid_o, // output port valid
    output [7:0]         seg_o // segment outputs
);

    reg [14:0] cnt;
    always @(posedge clk or negedge rstn)
    if(~rstn)
        cnt <= 0;
    else
        cnt <= cnt + 1;

    reg [NPorts-1:0] sel;
    always @(posedge clk or negedge rstn)
    if(~rstn)
        sel <= 0;
    else if(cnt == 0)
        sel <= sel == NPorts - 1 ? 0 : sel + 1;

    always @(sel, valid_i) begin
        valid_o = {NPorts{1'b1}};
        valid_o[sel] = ~valid_i[sel];
    end

    assign seg_o = ~seg_i[sel*8+:8];

endmodule

module led7seg_decode(input [3:0] digit, input valid, output reg [7:0] seg);

    always @(digit)
    if(valid)
        case(digit)
            0: seg = 8'b00111111;
            1: seg = 8'b00000110;
            2: seg = 8'b01011011;
            3: seg = 8'b01001111;
            4: seg = 8'b01100110;
            5: seg = 8'b01101101;
            6: seg = 8'b01111101;
            7: seg = 8'b00000111;
            8: seg = 8'b01111111;
            9: seg = 8'b01101111;
            10: seg = 8'b01110111;
            11: seg = 8'b01111100;
            12: seg = 8'b00111001;
            13: seg = 8'b01011110;
            14: seg = 8'b01111011;
            15: seg = 8'b01110001;
            default: seg = 0;
        endcase
    else seg = 8'd0;

endmodule
\end{tcblisting}

% \bibliographystyle{unsrt}
\bibliographystyle{gbt7714-numerical}
% \bibliographystyle{plain}
% \bibliography{.bib}
\end{document}